#!/usr/bin/env python

from argparse import ArgumentParser
from commands import getstatusoutput
import logging, sys, json, yaml, requests
from requests import RequestException
from yaml import YAMLError
from logging import debug, error, info
from re import search, escape
from os.path import isdir, isfile
from os import chmod, remove, chdir
from shutil import rmtree
from tempfile import NamedTemporaryFile
from subprocess import Popen, PIPE, STDOUT

def format(s, **kwds):
  return s % kwds

def rmrf(path):
  try:
    if isdir(path):
      rmtree(path)
    elif isfile(path):
      remove(path)
  except OSError as e:
    debug(format("When deleting %(path)s: %(msg)s (ignored)",
                 path=path, msg=str(e)))

def searchMany(name, exprs):
  if isinstance(exprs, list):
    for e in exprs:
      if search(e, name): return True
  elif exprs == True:
    return True
  return False

def filter(name, includeRules, excludeRules, includeFirst):
  if includeFirst:
    if searchMany(name, includeRules):
      return not searchMany(name, excludeRules)
    else:
      return False
  else:
    if searchMany(name, excludeRules):
      return False
    else:
      if includeRules is None:
        # process exclude first, and no explicit include rule: keep it
        return True
      else:
        return searchMany(name, includeRules)

def runInstallScript(script, dryRun, **kwsub):
  if dryRun:
    debug(format("Dry run: publish script follows:\n" + script, **kwsub))
    return 0
  with NamedTemporaryFile(delete=False) as fp:
    fn = fp.name
    fp.write(format(script, **kwsub))
  chmod(fn, 0700)
  debug(format("Created unpack script: %(file)s", file=fn))
  rv = execute(fn)
  remove(fn)
  debug(format("Unpack script %(file)s returned %(rv)d", file=fn, rv=rv))
  return rv

def execute(command):
  popen = Popen(command, shell=False, stdout=PIPE, stderr=STDOUT)
  linesIterator = iter(popen.stdout.readline, "")
  for line in linesIterator:
    debug(line.strip("\n"))  # yield line
  output = popen.communicate()[0]
  debug(output)
  exitCode = popen.returncode
  return exitCode

def grabOutput(command):
  popen = Popen(command, shell=False, stdout=PIPE, stderr=STDOUT)
  return (popen.returncode, popen.communicate()[0])

def jget(url):
  try:
    return requests.get(url).json()
  except (RequestException, ValueError) as e:
    error(format("Getting %(url)s gave %(msg)s", url=url, msg=str(e)))
    return {}

class CvmfsServer(object):

  def __init__(self, repository, modulefileTpl, pkgdirTpl, publishScriptTpl, dryRun=False):
    self._inCvmfsTransaction = False
    self._repository = repository
    self._modulefileTpl = modulefileTpl
    self._pkgdirTpl = pkgdirTpl
    self._publishScriptTpl = publishScriptTpl
    self._dryRun = dryRun
    self._countChanges = 0

  @property
  def repository(self):
    return self._repository

  def _kw(self, url, arch, pkgName, pkgVer):
    kw =  { "url": url, "package": pkgName, "version": pkgVer, "repo": self._repository,
            "arch": arch }
    kw.update({ "pkgdir": format(self._pkgdirTpl, **kw) })
    kw.update({ "modulefile": format(self._modulefileTpl, **kw) })
    return kw

  def installed(self, arch, pkgName, pkgVer):
    kw = self._kw(None, arch, pkgName, pkgVer)
    debug(format("%(repo)s: checking if %(package)s %(version)s is installed for %(arch)s", **kw))
    return isdir(kw["pkgdir"]) or isfile(kw["modulefile"])

  def install(self, url, arch, pkgName, pkgVer, deps):
    kw = self._kw(url, arch, pkgName, pkgVer)
    rv = runInstallScript(self._publishScriptTpl, self._dryRun, **kw)
    if rv == 0:
      self._countChanges += 1
    else:
      self._cleanup(arch, pkgName, pkgVer)
    return rv

  def _cleanup(self, arch, pkgName, pkgVer):
    kw = self._kw(None, arch, pkgName, pkgVer)
    debug(format("%(repo)s: cleaning up %(pkgdir)s and %(modulefile)s", **kw))
    rmrf(kw["pkgdir"])
    rmrf(kw["modulefile"])

  def transaction(self):
    if self._inCvmfsTransaction:
      debug(format("%(repo)s: already in a transaction", repo=self._repository))
      return True
    elif self._dryRun:
      info(format("%(repo)s: started transaction (dry run)", repo=self._repository))
      self._inCvmfsTransaction = True
      return True
    else:
      if execute([ "cvmfs_server", "transaction", self._repository ]) == 0:
        info(format("%(repo)s: started transaction", repo=self._repository))
        self._inCvmfsTransaction = True
        return True
      error(format("%(repo)s: cannot commence transaction: maybe another one is in progress?",
                   repo=self._repository))
      return False

  def abort(self, force=False):
    if not self._inCvmfsTransaction and not force:
      debug(format("%(repo)s: no transaction to abort", repo=self._repository))
      return True
    if self._dryRun and not force:
      info(format("%(repo)s: transaction aborted (dry run)", repo=self._repository))
      self._inCvmfsTransaction = False
      return True
    rv = execute([ "cvmfs_server", "abort", "-f", self._repository ])
    if rv == 0:
      info(format("%(repo)s: transaction aborted", repo=self._repository))
      self._inCvmfsTransaction = False
      return True
    error(format("%(repo)s: cannot abort transaction", repo=self._repository))
    return False

  def publish(self):
    if not self._inCvmfsTransaction:
      debug(format("%(repo)s: not in a transaction", repo=self._repository))
      return True
    if not self._countChanges:
      debug(format("%(repo)s: nothing to publish, cancelling transaction", repo=self._repository))
      return self.abort()
    info(format("%(repo)s: publishing transaction, %(npkg)d new package(s)",
                repo=self._repository, npkg=self._countChanges))
    if self._dryRun:
      info(format("%(repo)s: transaction published (dry run)", repo=self._repository))
      return True
    rv = execute([ "cvmfs_server", "publish", self._repository ])
    if rv == 0:
      info(format("%(repo)s: transaction published!", repo=self._repository))
      self._inCvmfsTransaction = False
      return True
    else:
      error(format("%(repo)s: cannot publish CVMFS transaction, aborting",
            repo=self._repository))
      self.abort()
      return False

class AliEnPackMan(object):

  def __init__(self, publishScriptTpl, dryRun=False):
    self._dryRun = dryRun
    self._publishScriptTpl = publishScriptTpl
    self._packs = None

  def _kw(self, url, arch, pkgName, pkgVer, deps):
    kw =  { "url": url, "package": pkgName, "version": pkgVer, "arch": arch, "dependencies": deps }
    return kw

  def installed(self, arch, pkgName, pkgVer):
    kw = self._kw(None, arch, pkgName, pkgVer, None)
    debug(format("PackMan: checking if %(package)s %(version)s is installed for %(arch)s", **kw))

    if self._packs is None:
      self._packs = {}
      for line in grabOutput([ "alien", "-exec", "packman", "list" ])[1].split("\n"):
        m = search(r"VO_ALICE@(.+?)::([^\s]+)", line)
        if not m: continue
        pkg = m.group(1)
        ver = m.group(2)
        if not pkg in self._packs:
          self._packs[pkg] = {}
        self._packs[pkg].update({ver: []})

    platf = self._packs.get(pkgName, {}).get(pkgVer, [])
    if len(platf) == 0:
      _,out = grabOutput([ "alien", "-exec", "ls",
                           format("/alice/packages/%(package)s/%(version)s", **kw) ])
      for line in out.split("\n"):
        if search(r"^[A-Za-z0-9]+-[A-Za-z0-9-_]+$", line):
          platf.append(line)

    return arch in platf

  def install(self, url, arch, pkgName, pkgVer, deps):
    kw = self._kw(url, arch, pkgName, pkgVer,
                  ",".join(["VO_ALICE@"+x["name"]+"::"+x["version"] for x in deps]))
    return runInstallScript(self._publishScriptTpl, self._dryRun, **kw)

  def transaction(self):
    return True

  def abort(self, force=False):
    return True

  def publish(self):
    return True

def sync(pub, architectures, baseUrl, includeRules, excludeRules, includeFirst, dryRun):
  for arch in architectures:
    packsUrl = baseUrl + "/" + arch + "/dist-direct"
    debug(format("Getting packages for architecture %(arch)s from %(url)s",
                 arch=arch, url=packsUrl))
    distPackages = []
    for p in jget(packsUrl):
      if p["type"] == "directory":
        distPackages.append(p["name"])
    distPackages.sort(key=lambda item: -len(item))
    for pkgName in distPackages:
      verUrl = packsUrl + "/" + pkgName
      debug(format("%(arch)s / %(pack)s: listing versions under %(url)s",
                   arch=arch,
                   pack=pkgName,
                   url=verUrl))
      vre = format("^%(pack)s-(.*?)$", pack=escape(pkgName))
      for v in jget(verUrl):
        if v["type"] != "directory": continue
        vmatch = search(vre, v["name"])
        if vmatch is None: continue
        pkgVer = vmatch.group(1)
        if not filter(pkgVer,
                      includeRules.get(pkgName, None),
                      excludeRules.get(pkgName, None),
                      includeFirst):
          debug(format("%(arch)s / %(pack)s / %(ver)s: excluded",
                       arch=arch,
                       pack=pkgName,
                       ver=pkgVer))
          continue

        if pub.installed(architectures[arch], pkgName, pkgVer):
          debug(format("%(arch)s / %(pack)s / %(ver)s: already installed: skipping",
                       arch=arch,
                       pack=pkgName,
                       ver=pkgVer))
        else:
          depsUrl = format("%(url)s/%(pack)s-%(ver)s",
                           url=verUrl, pack=pkgName, ver=pkgVer)
          fullUrl = format("%(depsUrl)s/%(pack)s-%(ver)s.%(arch)s.tar.gz",
                           depsUrl=depsUrl, pack=pkgName, ver=pkgVer, arch=arch)
          info(format("%(arch)s / %(pack)s / %(ver)s: getting package",
                      arch=arch,
                      pack=pkgName,
                      ver=pkgVer))
          deps = []
          for dep in jget(depsUrl):
            for pkg in distPackages:
              dre = format("^%(pack)s-(.*?)\.%(arch)s\.tar\.gz$",
                           pack=escape(pkg), arch=escape(arch))
              dmatch = search(dre, dep["name"])
              if dmatch:
                if pkg != pkgName:
                  deps.append({"name": pkg, "version": dmatch.group(1)})
                break
          info(" * Source: %s" % fullUrl)
          info(" * Dependencies: %s" % ", ".join([i["name"]+" "+i["version"] for i in deps]))

          if not pub.transaction():
            sys.exit(2)  # fatal
          else:
            rv = pub.install(fullUrl, architectures[arch], pkgName, pkgVer, deps)
          if rv != 0:
            error(format("%(arch)s / %(pack)s / %(ver)s: publish script failed with %(rv)d",
                         arch=arch, pack=pkgName, ver=pkgVer, rv=rv))

  # Publish eventually
  return pub.publish()

def main():
  parser = ArgumentParser()
  parser.add_argument("action")
  parser.add_argument("--config", "-c", dest="configFile", default="aliPublish.conf",
                      help="Configuration file")
  parser.add_argument("--debug", "-d", dest="debug", action="store_true", default=False,
                      help="Debug output")
  parser.add_argument("--abort-at-start", dest="abort", action="store_true", default=False,
                      help="Abort any pending CVMFS transaction at start")
  parser.add_argument("--dry-run", "-n", dest="dryRun", action="store_true", default=False,
                      help="Do not write or publish anything")
  args = parser.parse_args()
  
  logger = logging.getLogger()
  loggerHandler = logging.StreamHandler()
  logger.addHandler(loggerHandler)

  loggerHandler.setFormatter(logging.Formatter('%(levelname)-5s: %(message)s'))
  if args.debug: logger.setLevel(logging.DEBUG)
  else: logger.setLevel(logging.INFO)

  logging.getLogger("requests").setLevel(logging.WARNING)
  logging.getLogger("urllib3").setLevel(logging.WARNING)

  try:
    with open(args.configFile, "r") as cf:
      conf = yaml.safe_load(cf.read())
  except (IOError, YAMLError) as e:
    error( format("While reading %(configFile)s: " + str(e), configFile=args.configFile) )
    sys.exit(1)

  if conf is None: conf = {}
  if conf.get("include", None) is None: conf["include"] = {}
  if conf.get("exclude", None) is None: conf["exclude"] = {}

  if conf.get("package_dir", None) is None:
    conf["package_dir"] = "/cvmfs/%(repo)s/%(arch)s/%(package)s/%(version)s"

  doExit = False
  if not isinstance(conf.get("cvmfs_repository", None), basestring):
    error("cvmfs_repository must be a string")
    doExit = True
  if not isinstance(conf.get("architectures", None), dict):
    error("architectures must be a dict of dicts")
    doExit = True
  if not isinstance(conf.get("base_url", None), basestring):
    error("base_url must be a string")
    doExit = True
  if not isinstance(conf.get("package_dir", None), basestring):
    error("package_dir must be a string")
    doExit = True
  if not isinstance(conf.get("modulefile", None), basestring):
    error("modulefile must be a string")
    doExit = True
  if not isinstance(conf.get("cvmfs_script", None), basestring):
    error("cvmfs_script must be a string")
    doExit = True
  if doExit: sys.exit(1)

  debug("Configuration: " + json.dumps(conf, indent=2))
  incexc = conf.get("filter_order", "include,exclude")
  if incexc == "include,exclude": includeFirst = True
  elif incexc == "exclude,include": includeFirst = False
  else:
    error("filter_order can be include,exclude or exclude,include")
    sys.exit(1)

  if args.action in [ "sync-cvmfs", "sync-alien" ]:
    chdir("/")
    if args.action == "sync-cvmfs":
      archKey = "CVMFS"
      pub = CvmfsServer(repository=conf["cvmfs_repository"],
                        modulefileTpl=conf["modulefile"],
                        pkgdirTpl=conf["package_dir"],
                        publishScriptTpl=conf["cvmfs_script"],
                        dryRun=args.dryRun)
    else:
      archKey = "AliEn"
      pub = AliEnPackMan(publishScriptTpl=conf["alien_script"],
                         dryRun=args.dryRun)
    if args.abort:
      pub.abort(force=True)

    architectures = {}
    for arch,maps in conf["architectures"].iteritems():
      architectures[arch] = isinstance(maps, dict) and maps.get(archKey, arch) or arch
      debug(format("Arch %(arch)s is called %(archPub)s on %(pub)s",
                   arch=arch, archPub=architectures[arch], pub=archKey))

    sync(pub=pub,
         architectures=architectures,
         baseUrl=conf["base_url"],
         includeRules=conf["include"],
         excludeRules=conf["exclude"],
         includeFirst=includeFirst,
         dryRun=args.dryRun)
  else:
    error("Wrong action, use sync-cvmfs or sync-alien")
    sys.exit(1)

if __name__ == "__main__":
  main()
