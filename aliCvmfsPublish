#!/usr/bin/env python

from argparse import ArgumentParser
from commands import getstatusoutput
import logging, sys
from logging import debug, error, info
from json import loads, dumps
from yaml import safe_load, YAMLError
from requests import get
from re import search, escape
from os.path import isdir
from os import chmod, remove, chdir
from tempfile import NamedTemporaryFile
from subprocess import Popen, PIPE

def format(s, **kwds):
  return s % kwds

def search_many(name, exprs):
  if isinstance(exprs, list):
    for e in exprs:
      if search(e, name): return True
  elif exprs == True:
    return True
  return False

def filter(name, include_rules, exclude_rules, include_first):
  if include_first:
    if search_many(name, include_rules):
      return not search_many(name, exclude_rules)
    else:
      return False
  else:
    if search_many(name, exclude_rules):
      return False
    else:
      if include_rules is None:
        # process exclude first, and no explicit include rule: keep it
        return True
      else:
        return search_many(name, include_rules)

def unpack_script(script, **kwsub):
  with NamedTemporaryFile(delete=False) as fp:
    fn = fp.name
    fp.write(format(script, **kwsub))
  chmod(fn, 0700)
  debug(format("Created: %(file)s", file=fn))
  rv = execute(fn)
  remove(fn)
  return rv

def execute(command):
  popen = Popen(command, shell=False, stdout=PIPE)
  lines_iterator = iter(popen.stdout.readline, "")
  for line in lines_iterator:
    debug(line.strip("\n"))  # yield line
  output = popen.communicate()[0]
  debug(output)
  exitCode = popen.returncode
  return exitCode

def cvmfs_server_transaction(repo):
  global in_cvmfs_transaction
  if in_cvmfs_transaction:
    debug("Already in a transaction")
    return True
  else:
    if execute([ "cvmfs_server", "transaction", repo ]) == 0:
      info("Created a CVMFS transaction")
      in_cvmfs_transaction = True
      return True
    error("Cannot create CVMFS transaction. Maybe another transaction is in progress?")
    return False

def cvmfs_server_abort(repo, force=False):
  global in_cvmfs_transaction
  if not in_cvmfs_transaction and not force:
    debug("No owned transaction to abort")
    return True
  rv = execute([ "cvmfs_server", "abort", "-f", repo ])
  if rv == 0:
    info("Our CVMFS transaction aborted")
    in_cvmfs_transaction = False
    return True
  error("Cannot abort CVMFS transaction")
  return False

def cvmfs_server_publish(repo):
  global in_cvmfs_transaction
  if not in_cvmfs_transaction:
    debug("No change to publish")
    return True
  rv = execute([ "cvmfs_server", "publish", repo ])
  if rv == 0:
    info("Our CVMFS transaction published!")
    in_cvmfs_transaction = False
    return True
  else:
    error("Cannot publish CVMFS transaction, calling abort to clean up")
    cvmfs_server_abort(repo)
    return False

def sync():
  for arch in conf["architectures"]:
    url = conf["base_url"] + "/" + arch
    debug(format("Getting packages for architecture %(arch)s from %(url)s", arch=arch, url=url))
    packs = loads(get(url).text)  # nginx json: type, mtime, name
    for p in packs:
      if p["type"] != "directory" or p["name"] in [ "dist", "store" ]: continue
      debug(format("%(arch)s: listing versions for %(pack)s",
                   arch=arch,
                   pack=p["name"]))
      vurl = url + "/" + p["name"]
      vre = format("^%(pack)s-(.*?)\.%(arch)s\.tar\.gz$", pack=escape(p["name"]), arch=escape(arch))
      for v in loads(get(vurl).text):
        if v["type"] != "file": continue
        vmatch = search(vre, v["name"])
        if vmatch is None: continue
        pkgver = vmatch.group(1)
        if not filter(pkgver,
                  conf["include"].get(p["name"], None),
                  conf["exclude"].get(p["name"], None),
                  include_first):
          debug(format("%(arch)s: excluded package %(pack)s version %(ver)s",
                       arch=arch,
                       pack=p["name"],
                       ver=pkgver))
          continue
        pkgdir = format(conf["dest_dir"],
                        repo=conf["cvmfs_repository"],
                        arch=arch,
                        package=p["name"],
                        version=pkgver)
        debug(format("%(arch)s: package %(pack)s version %(ver)s to be published to %(pkgdir)s",
                    arch=arch,
                    pack=p["name"],
                    ver=pkgver,
                    pkgdir=pkgdir))
        if isdir(pkgdir):
          debug("==> skipping, already installed")
        else:
          if not cvmfs_server_transaction(conf["cvmfs_repository"]):
            sys.exit(2)  # fatal
          full_url = vurl+"/"+v["name"]
          debug(format("!!! we need to get %(url)s !!!", url=full_url))
          rv = unpack_script(conf["unpack_script"],
                        url=full_url, arch=arch, package=p["name"], ver=pkgver,
                        repo=conf["cvmfs_repository"], pkgdir=pkgdir)
          if rv != 0:
            cvmfs_server_abort(conf["cvmfs_repository"])

  # Publish eventually
  return cvmfs_server_publish(conf["cvmfs_repository"])

if __name__ == "__main__":
  parser = ArgumentParser()
  parser.add_argument("action")
  parser.add_argument("--config", "-c", dest="configFile", default="aliCvmfsPublish.conf",
                      help="Configuration file.")
  parser.add_argument("--debug", "-d", dest="debug", action="store_true", default=False)
  parser.add_argument("--abort-at-start", dest="abort", action="store_true", default=False)
  args = parser.parse_args()
  
  logger = logging.getLogger()
  logger_handler = logging.StreamHandler()
  logger.addHandler(logger_handler)

  if args.debug:
    logger_handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
    logger.setLevel(logging.DEBUG)
  else:
    logger.setLevel(logging.INFO)

  logging.getLogger("requests").setLevel(logging.WARNING)

  try:
    with open(args.configFile, "r") as cf:
      conf = safe_load(cf.read())
  except (IOError, YAMLError) as e:
    error( format("While reading %(configFile)s: " + str(e), configFile=args.configFile) )
    sys.exit(1)

  if conf.get("include", None) is None: conf["include"] = {}
  if conf.get("exclude", None) is None: conf["exclude"] = {}

  debug("Configuration: "+dumps(conf, indent=2))
  incexc = conf.get("filter_order", "include,exclude")
  if incexc == "include,exclude": include_first = True
  elif incexc == "exclude,include": include_first = False
  else:
    error("filter_order can be include,exclude or exclude,include")
    sys.exit(1)

  in_cvmfs_transaction = False

  if args.action == "sync":
    chdir("/")
    if args.abort:
      cvmfs_server_abort(conf["cvmfs_repository"], force=True)
    sync()
