#!/usr/bin/env python

from argparse import ArgumentParser
from commands import getstatusoutput
import logging, sys
from logging import debug, error, info
from json import loads, dumps
from yaml import safe_load, YAMLError
from requests import get
from re import search, escape
from os.path import isdir
from os import chmod, remove, chdir
from tempfile import NamedTemporaryFile
from subprocess import Popen, PIPE

def format(s, **kwds):
  return s % kwds

def search_many(name, exprs):
  if isinstance(exprs, list):
    for e in exprs:
      if search(e, name): return True
  elif exprs == True:
    return True
  return False

def filter(name, include_rules, exclude_rules, include_first):
  if include_first:
    if search_many(name, include_rules):
      return not search_many(name, exclude_rules)
    else:
      return False
  else:
    if search_many(name, exclude_rules):
      return False
    else:
      if include_rules is None:
        # process exclude first, and no explicit include rule: keep it
        return True
      else:
        return search_many(name, include_rules)

def unpack_script(script, **kwsub):
  with NamedTemporaryFile(delete=False) as fp:
    fn = fp.name
    fp.write(format(script, **kwsub))
  chmod(fn, 0700)
  debug(format("Created: %(file)s", file=fn))
  rv = execute(fn)
  remove(fn)
  return rv

def execute(command):
  popen = Popen(command, shell=False, stdout=PIPE)
  lines_iterator = iter(popen.stdout.readline, "")
  for line in lines_iterator:
    debug(line.strip("\n"))  # yield line
  output = popen.communicate()[0]
  debug(output)
  exitCode = popen.returncode
  return exitCode

class CvmfsServer(object):

  def __init__(self, repository):
    self._in_cvmfs_transaction = False
    self._repository = repository

  @property
  def repository(self):
    return self._repository

  def transaction(self):
    if self._in_cvmfs_transaction:
      debug(format("%(repo)s: already in a transaction", repo=self._repository))
      return True
    else:
      if execute([ "cvmfs_server", "transaction", self._repository ]) == 0:
        info(format("%(repo)s: started transaction", repo=self._repository))
        self._in_cvmfs_transaction = True
        return True
      error(format("%(repo)s: cannot commence transaction: maybe another one is in progress?",
                   repo=self._repository))
      return False

  def abort(self, force=False):
    if not self._in_cvmfs_transaction and not force:
      debug(format("%(repo)s: no transaction to abort", repo=self._repository))
      return True
    rv = execute([ "cvmfs_server", "abort", "-f", self._repository ])
    if rv == 0:
      info(format("%(repo)s: transaction aborted", repo=self._repository))
      self._in_cvmfs_transaction = False
      return True
    error(format("%(repo)s: cannot abort transaction", repo=self._repository))
    return False

  def publish(self):
    if not self._in_cvmfs_transaction:
      debug(format("%(repo)s: no change to publish", repo=self._repository))
      return True
    rv = execute([ "cvmfs_server", "publish", self._repository ])
    if rv == 0:
      info(format("%(repo)s: transaction published!", repo=self._repository))
      self._in_cvmfs_transaction = False
      return True
    else:
      error(format("%(repo)s: cannot publish CVMFS transaction, aborting",
            repo=self._repository))
      self.abort()
      return False

def sync(cvmfs, architectures, base_url, include_rules, exclude_rules, include_first,
         dest_dir_tpl, unpack_script_tpl):
  for arch in architectures:
    url = base_url + "/" + arch
    debug(format("Getting packages for architecture %(arch)s from %(url)s", arch=arch, url=url))
    packs = loads(get(url).text)  # nginx json: type, mtime, name
    for p in packs:
      if p["type"] != "directory" or p["name"] in [ "dist", "store" ]: continue
      debug(format("%(arch)s: listing versions for %(pack)s",
                   arch=arch,
                   pack=p["name"]))
      vurl = url + "/" + p["name"]
      vre = format("^%(pack)s-(.*?)\.%(arch)s\.tar\.gz$", pack=escape(p["name"]), arch=escape(arch))
      for v in loads(get(vurl).text):
        if v["type"] != "file": continue
        vmatch = search(vre, v["name"])
        if vmatch is None: continue
        pkgver = vmatch.group(1)
        if not filter(pkgver,
                      include_rules.get(p["name"], None),
                      exclude_rules.get(p["name"], None),
                      include_first):
          debug(format("%(arch)s: excluded package %(pack)s version %(ver)s",
                       arch=arch,
                       pack=p["name"],
                       ver=pkgver))
          continue
        pkgdir = format(dest_dir_tpl,
                        repo=cvmfs.repository,
                        arch=arch,
                        package=p["name"],
                        version=pkgver)
        debug(format("%(arch)s: package %(pack)s version %(ver)s to be published to %(pkgdir)s",
                    arch=arch,
                    pack=p["name"],
                    ver=pkgver,
                    pkgdir=pkgdir))
        if isdir(pkgdir):
          debug("==> skipping, already installed")
        else:
          if not cvmfs.transaction():
            sys.exit(2)  # fatal
          full_url = vurl+"/"+v["name"]
          debug(format("!!! we need to get %(url)s !!!", url=full_url))
          rv = unpack_script(unpack_script_tpl,
                             url=full_url, arch=arch, package=p["name"], ver=pkgver,
                             repo=cvmfs.repository, pkgdir=pkgdir)
          if rv != 0:
            cvmfs.abort()

  # Publish eventually
  return cvmfs.publish()

def main():
  parser = ArgumentParser()
  parser.add_argument("action")
  parser.add_argument("--config", "-c", dest="configFile", default="aliCvmfsPublish.conf",
                      help="Configuration file")
  parser.add_argument("--debug", "-d", dest="debug", action="store_true", default=False)
  parser.add_argument("--abort-at-start", dest="abort", action="store_true", default=False,
                      help="Abort any CVMFS transaction at start")
  parser.add_argument("--dry-run", "-n", dest="dryRun", action="store_true", default=False,
                      help="Do not write or publish anything")
  args = parser.parse_args()
  
  logger = logging.getLogger()
  logger_handler = logging.StreamHandler()
  logger.addHandler(logger_handler)

  if args.debug:
    logger_handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
    logger.setLevel(logging.DEBUG)
  else:
    logger.setLevel(logging.INFO)

  logging.getLogger("requests").setLevel(logging.WARNING)

  try:
    with open(args.configFile, "r") as cf:
      conf = safe_load(cf.read())
  except (IOError, YAMLError) as e:
    error( format("While reading %(configFile)s: " + str(e), configFile=args.configFile) )
    sys.exit(1)

  if conf.get("include", None) is None: conf["include"] = {}
  if conf.get("exclude", None) is None: conf["exclude"] = {}

  debug("Configuration: "+dumps(conf, indent=2))
  incexc = conf.get("filter_order", "include,exclude")
  if incexc == "include,exclude": include_first = True
  elif incexc == "exclude,include": include_first = False
  else:
    error("filter_order can be include,exclude or exclude,include")
    sys.exit(1)

  if args.action == "sync":
    cvmfs = CvmfsServer(conf["cvmfs_repository"])
    chdir("/")
    if args.abort:
      cvmfs.abort(force=True)
    sync(cvmfs=cvmfs,
         architectures=conf["architectures"],
         base_url=conf["base_url"],
         include_rules=conf["include"],
         exclude_rules=conf["exclude"],
         include_first=include_first,
         dest_dir_tpl=conf["dest_dir"],
         unpack_script_tpl=conf["unpack_script"])

if __name__ == "__main__":
  main()
