input {
  redis {
    host => "redis.marathon.mesos"
    key  => "logstash"
    data_type => "list"
  }
  #stdin {}
  http_poller {
    urls => {
      mesos_master => {
        method => get
        url => "http://leader.mesos:5050/metrics/snapshot"
        headers => {
          Accept => "application/json"
        }
      }
    }
    request_timeout => 60
    interval => 60
    codec => "json"
    tags => ["mesos_master_info"]
  }
}

filter {
  if "mesos_master_info" in [tags] {
	clone {
		clones => ["metric"]
		add_field => {  "metric" => "mesos_info/system mem_free_bytes %{system/mem_free_bytes}" }
		add_field => {  "metric" => "mesos_info/master uptime_secs %{master/uptime_secs}" }
		add_field => {  "metric" => "mesos_info/master tasks_lost %{master/tasks_lost}" }
		add_field => {  "metric" => "mesos_info/master slaves_active %{master/slaves_active}" }
		add_field => {  "metric" => "mesos_info/master cpus_percent %{master/cpus_percent}" }
		add_field => {  "metric" => "mesos_info/master mem_percent %{master/mem_percent}" }
		add_field => {  "metric" => "mesos_info/master elected %{master/elected}" }
	}
  }
  else if [message][0] =~ /Started by user/ {
    mutate {
      add_field => {"status" => "STARTED" }
      add_field => {"message_type" => "status"}
    }
  }
  else if [message][0] =~ /^Finished/ {
    grok {
      match => {"[message][0]" => "Finished: (?<status>[A-Z]+)"}
      add_field => {"message_type" => "status"}
    }
  }
  else if [message][0] =~ /^DEBUG:[^:]+:[^:]+: Commit hash for/ {
    grok {
      match => {"[message][0]" => "DEBUG:(?<main[name]>[^:]+):(?<main[hash]>[^:]+): Commit hash for (?<sources[repo]>[^@]*)@(?<sources[tag]>[^ ]*) is (?<sources[hash]>[^ ]*)"}
      add_field => {"message_type" => "sources"}
    }
  }
  else if [message][0] =~ /DEBUG:[^:]+:[^:]+:[ ]+[^:]*:[0-9]+:[0-9]+: warning:[ ]+(?!or)(?!but).*/ {
    grok {
      match => {"[message][0]" => "DEBUG:(?<main[name]>[^:]+):(?<main[hash]>[^:]+):[ ]+(/build/workarea/sw/[0-9]+/SOURCES/|/build/workarea/sw/[0-9]+/|)(?<filename>[^:]*):(?<line>[0-9]+):(?<column>[0-9]+): warning:[ ]+(?<what>.*)"}
      add_field => {"message_type" => "compilation_warning"}
    }
  }
  else if [message][0] =~ /DEBUG:[^:]+:[^:]+:[ ]+.*\/ld: warning:[ ].*/ {
    grok {
      match => {"[message][0]" => "DEBUG:(?<main[name]>[^:]+):(?<main[hash]>[^:]+):[ ]+(?<filename>[^:]*): warning:[ ]+(?<what>.*)"}
      add_field => {"message_type" => "compilation_error"}
    }
  }
  else if [message][0] =~ /DEBUG:[^:]+:[^:]+:[ ][0-9]+:aliroot-test:/ {
    grok {
      match => {"[message][0]" => "DEBUG:(?<main[name]>[^:]+):(?<main[hash]>[^:]+):[ ](?<test[timestamp]>[0-9]+):aliroot-test: (?<test[name]>[^ ]+) (?<test[status]>[A-Z]+)"}
      add_field => {"message_type" => "test_status"}
    }
  }
  else if [message][0] =~ /DEBUG: Using.*/ {
    grok {
      match => {"[message][0]" => "DEBUG: Using aliBuild from alibuild.(?<alibuild_hash>[a-f0-9]+) recipes in alidist.(?<alidist_hash>[a-f0-9]+)"}
      add_field => {"message_type" => "tools_info"}
    }
  }
  else {
    grok {
      match => {"[message][0]" => "DEBUG:(?<main[name]>[^:]+):(?<main[hash]>[^:]+):[ ]+(/build/workarea/sw/[0-9]+/SOURCES/|/build/workarea/sw/[0-9]+/|)(?<filename>[^:]*):(?<line>[0-9]+):(?<column>[0-9]+): fatal error:[ ]+(?<what>.*)"}
      add_field => {"message_type" => "compilation_error"}
    }
  }
  mutate {
    remove_field => ["message"]
  }

  if [type] == "metric" {
    split {
       field => "[metric]"
    }
    prune {
      whitelist_names => ["type", "@timestamp", "metric"]
    }
  }

  if "_grokparsefailure" in [tags] {
    drop { }
  }
}

output {
  # Metrics only go to monalisa, rest goes to elasticsearch.
  if [type] == "metric" {
    udp {
      host => "MONALISA_HOST"
      port => "MONALISA_PORT"
      codec => line {format => "%{[metric]}"}
    }
  } else if "mesos_master_info" in [tags] {
    elasticsearch {
      host => ["elasticsearch.marathon.mesos"]
      port => "9200"
      protocol => "http"
      index => "mesos-metrics-%{+YYYY.MM.dd}"
    }
  }
  else {
    elasticsearch {
      host => ["elasticsearch.marathon.mesos"]
      port => "9200"
      protocol => "http"
    }
  }
}
